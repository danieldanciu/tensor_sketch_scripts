# Computes the amount of overlap between each PACBIO simulated sequence and the closest sequence to it according to TSB
# Inputs:
#   - sd_0001.maf file generated by PBSIM; used for extracting the overlap between each simulated sequence
#       ./src/pbsim --data-type CLR --depth 9 --model_qc data/model_qc_clr 1813613.fna --length-mean 80
#   - distance triangle file generated by running TSB:
#       ./sketch -i /tmp/seqs/ -o /tmp/ed.csv -t 6 -block_size 2 -sketch_method TSB --action triangle

import re


# returns the number of bases that overlap between 2 sequences
def get_overlap(b1, e1, b2, e2):
    b = max(b1, b2)
    e = min(e1, e2)
    if b >= e:
        return 0
    else:
        return (e - b) / min(e1 - b1, e2 - b2)


# contains the alignment between each sequence and the original genome
f = open('/Users/dd/work/PBSIM-PacBio-Simulator/sd_0001.maf')
flines = f.readlines()
lines = []

# go through the MAF file and figure out the start/end position of each simulated PACBIO sequence
pacb_reads = []
for fline in flines:
    lines.append(fline)
    if len(lines) < 4:  # the algnment for each sequence takes 4 lines; skip the first sequence
        continue
    assert (lines[0] == 'a\n')  # first line in each alignment simply contains an 'a'
    assert (lines[1].startswith('s'))
    maf_tokens = re.split('[ \t]+', lines[1])  # the 2nd line contains "s genome_name start length strand(+/-) total_len
    assert (maf_tokens[0] == 's')
    align_start = int(maf_tokens[2])
    align_stop = align_start + int(maf_tokens[3])

    pacb_reads.append((align_start, align_stop))
    # print(align_start, align_stop, len(lines_seq[1][:-1]), seq, '\n')
    lines = []

# sort sequences by the start position
pacb_reads.sort(key=lambda tup: tup[0])

# distance triangle generated by running TSB
ftriangle = open('/tmp/ed.csv_6_3')

# read the triangle and transform it into a distance matrix
i = 0
dist = []
for line in ftriangle.readlines():
    tokens = line[:-1].split('\t')
    if len(tokens) == 1:
        dist.append([1])
        i = i + 1
        continue
    name = tokens[0]
    values = [float(v) for v in tokens[1:]]
    values.append(1)
    dist.append(values)
    for j in range(0, i):
        dist[j].append(values[j])
    i = i + 1

# show the amount of overlap between each sequence and the closest 2 sequences according to TSB
i = 0
for values in dist:
    index_min = min(range(len(values)), key=values.__getitem__)
    overlap = get_overlap(pacb_reads[i][0], pacb_reads[i][1], pacb_reads[index_min][0],
                          pacb_reads[index_min][1])
    del values[index_min]
    index_min2 = min(range(len(values)), key=values.__getitem__)
    overlap2 = get_overlap(pacb_reads[i][0], pacb_reads[i][1], pacb_reads[index_min2][0],
                           pacb_reads[index_min2][1])

    del values[index_min2]
    index_min3 = min(range(len(values)), key=values.__getitem__)
    overlap3 = get_overlap(pacb_reads[i][0], pacb_reads[i][1], pacb_reads[index_min3][0],
                           pacb_reads[index_min3][1])

    print(values[index_min], overlap, overlap2, overlap3)
    i = i + 1
